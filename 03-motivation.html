<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="generator" content="pandoc">
    <title>Software Carpentry: Instructor Training</title>
    <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico" />
    <link rel="stylesheet" href="css/bootstrap/bootstrap.css" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="stylesheet" href="css/bootstrap/bootstrap-responsive.css" />
    <link rel="stylesheet" type="text/css" href="css/swc.css" />
    <link rel="alternate" type="application/rss+xml" title="Software Carpentry Blog" href="http://software-carpentry.org/feed.xml"/>
    <meta charset="UTF-8" />
    <!-- HTML5 shim, for IE6-8 support of HTML5 elements -->
    <!--[if lt IE 9]>
      <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
  </head>
  <body>
    <div class="container">
      <div class="banner">
        <a href="http://software-carpentry.org" title="Software Carpentry">
          <img alt="Software Carpentry banner" src="img/software-carpentry-banner.png" />
        </a>
      </div>
      <div class="row-fluid">
        <div class="span10 offset1">
          <h1 class="title">Instructor Training</h1>
          <h2 class="subtitle">Relevance and Empowerment</h2>
<div id="learning-objectives" class="objectives objectives">
<h2>Learning Objectives</h2>
<ul>
<li>FIXME</li>
</ul>
</div>
<p>Discussion of the practical implications of learning concepts brings us to our next big idea: people learn best when they care about the topic <em>and</em> believe they can master it. Neither fact is particularly surprising, but their practical implications have a lot of impact on what we teach and the order in which we teach it.</p>
<p>First, most scientists don't actually want to program. They want to do scientific research, and programming is a tax they have to pay along the way. They don't care how hash tables work, or even that hash tables exist; they just want to know how to process data faster. We therefore have to make sure that everything we teach is useful right away, and conversely that we don't teach anything just because it's &quot;fundamental&quot;.</p>
<p>Second, believing that something will be hard to learn is a self-fulfilling prophecy. This is why it's important not to say that something is easy: if someone who has been told that tries it, and it doesn't work, they are more likely to become discouraged.</p>
<p>It's also why installing and configuring software is a much bigger problem for us than experienced programmers like to acknowledge. It isn't just the time we lose at the start of boot camps as we try to get a Unix shell working on Windows or set up a version control client on some idiosyncratic Linux distribution. It isn't even the unfairness of asking students to debug things that depend on precisely the knowledge they have come to learn, but which they don't yet have. The real problem is that every such failure reinforces the belief that computing is hard, and that they'd have a better chance of making next Thursday's conference submission deadline if they kept doing things the way they always have.</p>
<p>For these reasons, we have adopted a &quot;teach most immediately useful first&quot; approach. Imagine a grid whose axes are labelled &quot;mean time to master&quot; and &quot;usefulness once mastered&quot;. Everything that's quick to master, and immediately useful should be taught first; things in the opposite corner that are hard to learn and have little near-term application don't belong in this course.</p>
<p>Many of the foundational concepts of computer science, such as computability, inhabit the &quot;useful but hard to learn&quot; corner of the grid described above. This doesn't mean that they aren't worth learning, but if our aim is to convince people that they <em>can</em> learn this stuff, and that doing so will help them do more science faster, they are less compelling than things like automating repetitive tasks.</p>
<p>And note: any useful estimate of how long something takes to master must take into account how frequent failures are and how much time is lost to them. For example, editing a text file seems like a simple task, but most GUI editors save things to the user's desktop or home directory. If people need to run shell commands on the files they've edited, a substantial fraction won't be able to navigate to the right directory without help.</p>
<h3 id="techniques-for-motivating-content">Techniques for Motivating Content</h3>
<p>As discussed above, it's crucial that students believe in the value of the material, and their ability to master it. But, reciting impressive technical specifications of a tool often falls flat with beginners, and unsubstantiated cheerleading becomes transparent quickly. Here are some simple techniques to build authentic and compelling motivation:</p>
<ul>
<li><strong>Relate the material to learners' existing practice</strong>. One of the most compelling pitches for git I ever heard was from someone in the social sciences, who explained how git was a tool for <em>editing manuscripts</em>. The students had long ago internalized the value and importance of editing text; this pitch painted version control as simply a tool for helping them continue their existing practice in the world of code.</li>
<li><strong>Tell a personal story</strong> of how you use the tool or idea. By painting a human picture of using this material, you make it more relatable and thus less intimidating. What's more, if you can help your students relate to your real experiences using the material, you start to build a sense of <em>community</em> around using and learning these ideas. And if you have an authentic story to tell about struggling to learn these concepts the first time - tell it. Understanding that even the instructor struggled at first lets students know that their own struggles are normal, and nothing to be discouraged by.</li>
<li>Don't be afraid to step back and call out the <strong>big ideas</strong>. Sure, git is great for managing changes; but this lets us <em>experiment fearlessly</em>, since we know we can always retreat to a previous commit. Sure, scripting can be a powerful convenience tool; but it also lets us <em>build ambitiously</em>, since building small, unix-style programs give us a rock-solid foundation to build on. The rest of the lesson can focus on the technical details; when motivating material, take a moment to call out the exciting spirit and opportunities it affords in a way that's compelling beyond the technical.</li>
</ul>
<h2 id="mindset-stereotype-threat-and-diversity">Mindset, Stereotype Threat, and Diversity</h2>
<p>Carol Dweck and others have found that if you tell people that ability at some task is intrinsic (i.e., that you either have the gene or you don't), <em>everyone</em> does worse, including the supposedly advantaged. The reason is that if they don't get it at first, they figure they just don't have the gene, which biases future performance. On the other hand, if people believe that a skill will improve with practice, everybody does better on average.</p>
<p>A related concept is stereotype threat. In brief, reminding people of negative stereotypes, even in subtle ways, increases their nervousness and therefore their likelihood of failure.</p>
<p>The biggest negative stereotypes in computing are gender-related. Depending on whose numbers you trust, only 12-18% of programmers are women, and those figures have actually been getting worse over the last 20 years. There are many reasons for this (see <em>Unlocking the Clubhouse</em> or the Whitecraft and Williams paper in the reading for discussion), but as far as Software Carpentry goes, the most important thing is to avoid both overt and covert reminders of social stereotypes of programmers.</p>
<p>We try to act on this in two ways. First, we repeatedly emphasize that practice makes perfect. We also code live in front of our learners instead of using slides, so that they can see us make mistakes. Doing this gives them permission to make mistakes too: after all, if we're not perfect, they can't be expected to be either. Having to type things in ourselves also slows us down, so that learners are less likely to fall behind.</p>
<p>Second, we have found that learners get more out of boot camps if they attend in groups, e.g., if entire lab groups come, or if attendees are drawn from the same (or closely-related) disciplines. Doing this ensures that everyone in the room knows in advance that they're going to be with at least a few people they trust, and that they aren't going to be the only one in the room who doesn't get it. It also helps after the workshop: if someone comes on their own and then returns to their lab, they have to roll a big rock up a steep hill all by themselves. If they come with their labmates, on the other hand, they can work together after the bootcamp to implement what they've learned.</p>
<h2 id="media-first-computation">Media-First Computation</h2>
<p>FIXME: Guzdial and Ericson's work</p>
<div id="fixme" class="challenge">
<h2>FIXME</h2>
<p>FIXME</p>
</div>
        </div>
      </div>
      <div class="footer">
        <a class="label swc-blue-bg" href="http://software-carpentry.org">Software Carpentry</a>
        <a class="label swc-blue-bg" href="https://github.com/swcarpentry/instructor-training">Source</a>
        <a class="label swc-blue-bg" href="mailto:admin@software-carpentry.org">Contact</a>
        <a class="label swc-blue-bg" href="LICENSE.html">License</a>
      </div>
    </div>
    <!-- Javascript placed at the end of the document so the pages load faster -->
    <script src="http://software-carpentry.org/v5/js/jquery-1.9.1.min.js"></script>
    <script src="http://software-carpentry.org/v5/js/bootstrap/bootstrap.min.js"></script>
  </body>
</html>
